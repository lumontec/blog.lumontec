import { lumontec } from '@/authors'
import image from './card.jpg'
import arch from './1_arch.png'

export const meta = {
  title: 'Building a security tracing utility to snoop into the linux kernel',
  description: `The story of how I built lsmtrace, a linux security modules introspection utility. A quick example demonstrating how it's possible to take a swim at the bottom of the linux kernel to observe security events triggered by a specific process. Leveraging krsi and ebpf this gets as easy as writing a simple c application. Almost.. `,
  date: '2021-02-04T19:35:02.037Z',
  authors: [lumontec],
  image,
  discussion: 'https://github.com/lumontec/lsmtrace',
}

<!--excerpt-->
The story of how I built **[lsmtrace](https://github.com/lumontec/lsmtrace)**, a linux security modules introspection utility.
A quick example demonstrating how it's possible to take a swim at the bottom of the linux kernel to observe security events triggered by a specific process. Leveraging [krsi](https://lwn.net/Articles/798157/) and [ebpf](https://ebpf.io/) this gets as easy as writing a simple c application. Almost..

<!--/excerpt-->

<p className="prose-lg">
The story of how I built <a href="https://github.com/lumontec/lsmtrace"><strong>lsmtrace</strong></a>, a linux security modules introspection utility.
A quick example demonstrating how it's possible to take a swim at the bottom of the linux kernel to observe security events triggered by a specific process. Leveraging <a href="https://lwn.net/Articles/798157/"><strong>krsi</strong></a>  and <a href="https://ebpf.io/"><strong>ebpf</strong></a> this gets as easy as writing a simple c application.  
Almost..
</p>

--- 

## Quest

During my quest for barely understandable technology I stumbled upon a really interesting feature released with kernel version v5.7 called **[krsi](https://lwn.net/Articles/798157/)** (kernel runtime security instrumentation) or bpf_lsm that allows developers to implement flexible [linux security modules](https://it.wikipedia.org/wiki/Linux_Security_Modules) in userspace by exploiting the functionalities exposed by [extended bpf](https://prototype-kernel.readthedocs.io/en/latest/bpf/). If you lack a basic idea of how these two techs work just jump to my previous post.  
Beeing the tech super-fresh I culdn't find any project built on this in the open source community, so I started *dreaming* about developing one myself. That quickly made me want to discover more about the linux security modules framework, as well as realizing that the docs for the hundred+more hooks exposed by the kernel is pretty much **non-existent**.  
Well.. we are in for some true fun.   
I came to the conclusion that the best way for studying theese hooks was indeed to build some tool for observing them while they operate, that's why I developed a simple utilty which i called [lsmtrace](https://github.com/lumontec/lsmtrace). 

--- 

## lsmtrace

The idea of lsmtrace is to dump every hook event triggered by a specific executable along with a meaningful view of the hook call arguments. But what does that mean actually ?  
Well the utility will basically do three things:
1. Attach to all linux security modules hooks
2. Spawn the process being monitored
3. Dump events once hooks are triggered by the executable 

## Implementation

The utility can be simply divided in two distinct components:
* kernelspace bpf probe
* userspace executable

Both of them make extensive usage of **libbpf** library in order to:
* loading and confiuguring ebpf probe
* attach to hooks at the kernel side
* safely access information at the kernel side
* stream information to userspace using the bpf ringbuffer

This architectural diagram should provide you with a mental representation of the details that 
follow:

<img
  class="crisp p-5 border border-gray-200 rounded-md"
  src={arch} 
/>

### kernelspace bpf probe

Contains the programs that will be attached to the hooks, every hook call will generate one or more events embedding information directly extracted by the hooks arguments. 
This will include: 
* *hook function signature*
* *struct arguments information* 
 
These events will be efficiently pushed to userspace by means of the **[bpf ringbuffer](https://www.kernel.org/doc/html/latest/bpf/ringbuf.html)**, a kernel bpf faciltiy of type <code>BPF_MAP_TYPE_RINGBUF</code> that implements an in-kernel circular buffer which can be used to stream information to userspace. Thus every kernel hook will have attached a simple program declared as follows:

```c
SEC("lsm/file_open")
int BPF_PROG(file_open, struct file *file)
{

	FILTER_CATHEGORY_INT(FILE_CATH)
	FILTER_OWN_PID_INT()
	DUMP_FUNC(file_open, struct file *file)
	
	DUMP_FILE_STRUCT(file)

	bpf_printk("lsm_hook: file: file_open\n");
	return 0;
}
``` 

Without entering too much detail, we simply declare the hook we will attach to, with the arguments that will be passed, and we call a number of macros which basically have theese roles:

<code>FILTER_CATHEGORY_INT()</code>   filter out hook cathegory (set by userspace at probe launch)  <br/>  
<code>FILTER_OWN_PID()</code>  filter hook calls related to specific pid (set by userspace at probe launch)  <br/>  
<code>DUMP_FUNC()</code>  dump hook signature event (push to ringbuf) <br/>  
<code>DUMP_FILE_STRUCT()</code>  dump view of the file struct (push to ringbuf) <br/>  

In addition for debug purposes we trace the operation with <code>bpf_printk</code> which can be inspected with:
<code> cat /sys/kernel/debug/tracing/trace_pipe </code>

What follows is an example implementation of one of the previous event dump macros:

```c
#define DUMP_FUNC(FNAME, ...) {                             \
	const char func_call_name[] = #FNAME;                   \
	const char func_call_args[] = #__VA_ARGS__;             \
	dump_func(func_call_name, func_call_args);              \
}	

...

static int dump_func(const char *fname, const char *fargs) {

	struct func_call_Event *evt; 								
	char func_call_label[] = "HOOK_CALL";

	evt = bpf_ringbuf_reserve(&ringbuf, sizeof(*evt), ringbuffer_flags);

	if (!evt)										
		return -1;									

	evt->super.etype = FUNCTION_CALL;

	bpf_probe_read_str(evt->super.label, sizeof(evt->super.label), func_call_label);	
	bpf_probe_read_str(evt->name, sizeof(evt->name), fname);				
	bpf_probe_read_str(evt->args, sizeof(evt->args), fargs);				

	bpf_ringbuf_submit(evt, ringbuffer_flags);						

	return 0;
}
```

As you see inside the <code>dump_func</code> definition, we simply allocate a new event and assign it a label, we set the name and the arguments. In order to push this information to the ringbuffer we need to first reserve enough space on the buffer with <code>bpf_ringbuf_reserve</code> and submit the forged event with <code>bpf_ringbuf_submit</code>  

You may have immediately noticed a couple of quirks:

1. Most of this code operates on variables by making use of specific helper functions (e.g. <code>bpf_prove_read_str</code> exposed along with the previous ones by the **libbpf** library. This required in order to safely read information inside the kernel

2. The macro definition has a strange form, declares a local string inside <u>a code block</u> and then calls the <code>dump_func</code> passing this string. This is really required because declaring a string literal outside of the block generates an error <code>libbpf: elf: skipping unrecognized data section(6) .rodata.str1.1</code> due to the fact that libbpf does not support string literals in the **rodata** elf section atm. To work this around a simple quick solution is to declare the literal inside a code block in such a way that it can be simply allocated **on the stack**.

A similar logic is also implemented to dump hook arguments, referring to the <code><strong>file_open</strong></code> call for example we can extract information from the <code>file</code> struct as follows:

```c
/* file */
#define DUMP_FILE_STRUCT(...) {                                     \
	DUMP_MEMBER_UINT(__VA_ARGS__,f_mode)                            \
	DUMP_DENTRY_STRUCT(__VA_ARGS__,f_path.dentry)                   \
}	

...

#define DUMP_MEMBER_UINT(...) {                                     \
	const char dump_member_name[] = #__VA_ARGS__;                   \
	unsigned int mptr = BPF_CORE_READ(__VA_ARGS__);                 \
	dump_uint_member(dump_member_name, mptr);                       \
}

```

As you see nested macro definitions have been implemented in order to allow reuse of <code>DUMP...STRUCT()</code> logic.   
Macro <code>BPF_CORE_READ()</code> is a libbpf helper which allows us to safely access kernel structure members across different versions.  
[This post](https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html) will provide you with much greater detail.

### Userspace executable

At the userspace side the application entrypoint looks more or less like this:

```c
...
	/* Parse command line arguments */
	err = argp_parse(&argp, argc, argv, 0, NULL, NULL);
	if (err)
		return err;
...

	int child_pid = exec_prog_and_wait(my_exec_path, my_exec_argv);
...
	/* Configure bpf probe with init values */
	skel->bss->my_pid = child_pid;
	skel->rodata->cathegory = argp_args.cathegory;
...

	/* Attach tracepoints */
	err = lsmtrace_bpf__attach(skel);
	if (err) {
		log_err("Failed to attach BPF skeleton\n");
		goto cleanup;
	}

	/* Send child cont signal */
	log_verb("Attached, starting execution\n");
	kill(child_pid, SIGCONT);	

	/* Set up ring buffer polling */
	ringbuffer = ring_buffer__new(bpf_map__fd(skel->maps.ringbuf), handle_event, NULL, NULL);
	if (!ringbuffer) {
		err = -1;
		log_err("Failed to create ring buffer\n");
		goto cleanup;
	}
...
	while (!exiting) {
...

		err = ring_buffer__poll(ringbuffer, 100 /* timeout, ms */);
...
	}

```

This is pretty straightforward, but just to condense it: after parsing command line args we <u>spawn the target executable</u> to be traced, then we initialize the bpf probe with the pid to be filtered and attach it to the hooks. Right after that we see that a <code>kill(child_pid,<strong>SIGCONT</strong>)</code> signal is sent to our process. That is because the new process is **waited** as soon as its spawned by the main thread, so that it can be conveniently converted my an <code><strong>execve()</strong></code> call right after all hooks have been attached at the kernel side.




## Let`s have some fun

## Some brainfood

--- 

## Wrapping the spring roll 

Writing an deployng flexible security code has never been so easy, I expect to see a number of different solutions grow building their foundation on KRSI and bpf.  
Deep lsm observability will likely become another quite crucial aspect both when deveoloping and deploying these kind of programs. That is exatcly why I wrote a simple security [**tracer**](https://github.com/lumontec/lsmtrace) to provide an high level view of what a specific process is doing at the hooks level.  
That is juice for my next post. 

