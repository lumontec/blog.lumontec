import { lumontec } from '@/authors'
import image from './card.jpg'
import arch from './1_arch.png'

export const meta = {
  title: 'Building a security tracing utility to snoop into the linux kernel',
  description: `The story of how I built lsmtrace, a linux security modules introspection utility. A quick example demonstrating how it's possible to take a swim at the bottom of the linux kernel to observe security events triggered by a specific process. Leveraging krsi and ebpf this gets as easy as writing a simple c application. Almost.. `,
  date: '2021-02-04T19:35:02.037Z',
  authors: [lumontec],
  image,
  discussion: 'https://github.com/lumontec/lsmtrace',
}

<!--excerpt-->
The story of how I built **[lsmtrace](https://github.com/lumontec/lsmtrace)**, a linux security modules introspection utility.
A quick example demonstrating how it's possible to take a swim at the bottom of the linux kernel to observe security events triggered by a specific process. Leveraging [krsi](https://lwn.net/Articles/798157/) and [ebpf](https://ebpf.io/) this gets as easy as writing a simple c application. Almost..

<!--/excerpt-->

<p className="prose-lg">
The story of how I built <a href="https://github.com/lumontec/lsmtrace"><strong>lsmtrace</strong></a>, a linux security modules introspection utility.
A quick example demonstrating how it's possible to take a swim at the bottom of the linux kernel to observe security events triggered by a specific process. Leveraging <a href="https://lwn.net/Articles/798157/"><strong>krsi</strong></a>  and <a href="https://ebpf.io/"><strong>ebpf</strong></a> this gets as easy as writing a simple c application.  
Almost..
</p>

--- 

## Quest

During my quest for barely understandable technology I stumbled upon a really interesting feature released with kernel version v5.7 called **[krsi](https://lwn.net/Articles/798157/)** (kernel runtime security instrumentation) or bpf_lsm that allows developers to implement flexible [linux security modules](https://it.wikipedia.org/wiki/Linux_Security_Modules) in userspace by exploiting the functionalities exposed by [extended bpf](https://prototype-kernel.readthedocs.io/en/latest/bpf/). If you lack a basic idea of how these two techs work just jump to my previous post.  
Beeing the tech super-fresh I culdn't find any project built on this in the open source community, so I started *dreaming* about developing one myself. That quickly made me want to discover more about the linux security modules framework, as well as realizing that the docs for the hundred+more hooks exposed by the kernel is pretty much **non-existent**.  
Well.. we are in for some true fun.   
I came to the conclusion that the best way for studying theese hooks was indeed to build some tool for observing them while they operate, that's why I developed a simple utilty which i called [lsmtrace](https://github.com/lumontec/lsmtrace). 

--- 

## lsmtrace

The idea of lsmtrace is to dump every hook event triggered by a specific executable along with a meaningful view of the hook call arguments. But what does that mean actually ?  
Well the utility will basically do three things:
1. Attach to all linux security modules hooks
2. Spawn the process being monitored
3. Dump events once hooks are triggered by the executable 

## Architecture

The utility can be simply divided in multiple separated components:

### kernelspace bpf probe

Contains the programs that will be attached to the hooks, every hook call will generate one or more events embedding information directly extracted by the hooks arguments. 
This will include: 
* *hook function signature*
* *struct arguments information* 
 
These events will be efficiently pushed to userspace by means of the **[bpf ringbuffer](https://www.kernel.org/doc/html/latest/bpf/ringbuf.html)**, a kernel bpf faciltiy of type <code>BPF_MAP_TYPE_RINGBUF</code> that implements an in-kernel circular buffer which can be used to stream information to userspace. Thus every kernel hook will have attached a simple program declared as follows:

```c
SEC("lsm/file_open")
int BPF_PROG(file_open, struct file *file)
{

	FILTER_CATHEGORY_INT(FILE_CATH)
	FILTER_OWN_PID_INT()
	DUMP_FUNC(file_open, struct file *file)
	
	DUMP_FILE_STRUCT(file)

	bpf_printk("lsm_hook: file: file_open\n");
	return 0;
}
``` 

Without entering too much detail, we simply declare the hook we will attach to, with the arguments that will be passed, and we call a number of macros which basically have theese roles:

<code>FILTER_CATHEGORY_INT()</code>   filter out hook cathegory (set by userspace at probe launch)  <br/>  
<code>FILTER_OWN_PID()</code>  filter hook calls related to specific pid (set by userspace at probe launch)  <br/>  
<code>DUMP_FUNC()</code>  dump hook signature event (push to ringbuf) <br/>  
<code>DUMP_FILE_STRUCT()</code>  dump view of the file struct (push to ringbuf) <br/>  

In addition for debug purposes we trace the operation with <code>bpf_printk</code> which can be inspected with:
<code> cat /sys/kernel/debug/tracing/trace_pipe </code>

What follows is an example implementation of one of the previous event dump macros:

```c
#define DUMP_FUNC(FNAME, ...) {                             \
	const char func_call_name[] = #FNAME;                   \
	const char func_call_args[] = #__VA_ARGS__;             \
	dump_func(func_call_name, func_call_args);              \
}	

...

static int dump_func(const char *fname, const char *fargs) {

	struct func_call_Event *evt; 								
	char func_call_label[] = "HOOK_CALL";

	evt = bpf_ringbuf_reserve(&ringbuf, sizeof(*evt), ringbuffer_flags);

	if (!evt)										
		return -1;									

	evt->super.etype = FUNCTION_CALL;

	bpf_probe_read_str(evt->super.label, sizeof(evt->super.label), func_call_label);	
	bpf_probe_read_str(evt->name, sizeof(evt->name), fname);				
	bpf_probe_read_str(evt->args, sizeof(evt->args), fargs);				

	bpf_ringbuf_submit(evt, ringbuffer_flags);						

	return 0;
}
```

As you see inside the <code>dump_func</code> definition, we simply allocate a new event and assign it a label, we set the name and the arguments. In order to push this information to the ringbuffer we need to first reserve enough space on the buffer with <code>bpf_ringbuf_reserve</code> and submit the forged event with <code>bpf_ringbuf_submit</code>  

You may have immediately noticed a couple of quirks:

1. Most of this code operates on variables by making use of specific helper functions (e.g. <code>bpf_prove_read_str</code> exposed along with the previous ones by the **libbpf** library. This required in order to safely read information inside the kernel

2. The macro definition has a strange form, declares a local string inside <u>a code block</u> and then calls the <code>dump_func</code> passing this string. This is really required because declaring a string literal outside of the block generates an error <code>libbpf: elf: skipping unrecognized data section(6) .rodata.str1.1</code> due to the fact that libbpf does not support string literals in the **rodata** elf section atm. To work this around a simple quick solution is to declare the literal inside a code block in such a way that it can be simply allocated **on the stack**.

A similar logic is also implemented to dump hook arguments, referring to the <code><strong>file_open</strong></code> call for example we can extract information from the <code>file</code> struct as follows:

```c
/* file */
#define DUMP_FILE_STRUCT(...) {                                     \
	DUMP_MEMBER_UINT(__VA_ARGS__,f_mode)                            \
	DUMP_DENTRY_STRUCT(__VA_ARGS__,f_path.dentry)                   \
}	

...

#define DUMP_MEMBER_UINT(...) {                                     \
	const char dump_member_name[] = #__VA_ARGS__;                   \
	unsigned int mptr = BPF_CORE_READ(__VA_ARGS__);                 \
	dump_uint_member(dump_member_name, mptr);                       \
}

```

As you see nested macro definitions have been implemented in order to allow reuse of <code>DUMP...STRUCT()</code> logic.   
Macro <code>BPF_CORE_READ()</code> is a libbpf helper which allows us to safely access kernel structure members across different versions.  
[This post](https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html) will provide you with much greater detail.








<img
  class="crisp p-5 border border-gray-200 rounded-md"
  src={arch} 
/>



## Implementation details

### Complexities

### Quirks

## Let`s have some fun

## Some brainfood

Other tools are present, bpftrace ...
If you want to develop the sanbox



Linux is a constantly evolving incredibly widespread operating system, and it should be pretty straightforward to understand that for these two reasons alone providing strong guarantees about security is a really complex matter. The faster the technology evolves the more fixes are needed and faster deployment of those will be required. Those are the two main reasons that drove kernel developers to design an extremely low level framework exposing a number of hooks which are capable of authorizing or rejecting specific operations happening against sensible kernel resources. 

The architecture of linux security modules is based on 3 main concepts:
* *Locality*: Hooks are invoked as close as possible to the resource being protected to deter against [TOCTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) exploits 
* *Single reposnibility*: Hooks offer protection for very specific classes of operations
* *Agnostic*: Hooks are simple function declarations that security engineers use to define their own implementation of security modules

That third point in particular is quite important because it frees the linux kernel from any sort of specific security model implementation allowing third party developers to implement their own frameworks as well as to easily replace / fix them in case vulnerabilities emerge in their codebase. Quite famous examples of these implementations are Apparmor and SELinux which (at the time of this post) is the default security module enabled on every single android device available on the market btw.


--- 

## eBPF and libbpf 

Bpf is a quite old technology born with its roots in the packet capture field (close to tcpdump) but just recently extended to provide developers with the capability to inject custom code inside the linux kernel without any need to recompile the kernel itself. These bpf programs can be attached to specific kernel facilities like *tracepoints* or *kprobes* and can be flexibly deployed to implement powerful tracing and kernel observability tools. [Bcc](https://github.com/iovisor/bcc) and [bpftrace](https://github.com/iovisor/bpftrace) are two examples of tools that leverage extended bpf to provide the user with insightful metrics at a minimal performance costs.  

And that's *almost* awasome..

I mean it is awasome, but writing bpf programs is not really that easy for a number of reasons, consider that our code gets injected in the kernel thus has to be verified of beeing free of circular dependencies or infinite loops or unsafe access to memory .. Everything that could panic or halt your os (and sometimes even straight correct code) is rejected by one mythological kernel routine called `the bpf verifier` that is pickier than your girlfriend in the wrong day. But that is not all. 
The linux kernel is constantly evolving by changing and moving its internal structures as versions change, then how do I write code that is actually portable between these ? 

Libbpf is a library that aims to simplify the deployment of bpf programs by offering a number of helper functions useful to access internal kernel information providing a stable view of these structures. A functionalty called CO-RE (compile once run everywhere) magically hides from user a quantity of pointer chasing and field relocation logic, allowing us to happily access **with some limitations** a stable view of kernel information across different machines. 

--- 

## eBPF + LSM = KRSI freshness 

Linux kernel v5.7 included a really interesting [patch](https://lwn.net/ml/linux-kernel/20200220175250.10795-1-kpsingh@chromium.org/), that allows security people to design custom policies which can be injected in-kernel to be triggered by the security hooks exposed by the LSM framework. 
KRSI stands for Kernel Runtime Security Instrumentation and the target of this patch is to allow users to implement lsm hooks by utilizing bpf compiled code.
This gets interesting for a couple of reasons:
* *Kernel function call flow mutation*: AFAIK this is the very first application of ebpf where injected code is actually capable reject / blocking the execution of some kernel logic
* *Flexibility*: ebpf can be attached / removed on the fly offering fast replacement of vulerable security code   

This is a quite huge advancement that hasn't come without strong [debate](https://lwn.net/Articles/813261/) about performance and critycism with the main point being the following:  
**Lsm hooks are not an api:** this is actually a problem that follows the power of ebpf, due to the fact that it can basically consume information from everywhere in the kernel, it ends up using anything as as api, and api need to be stable. That is basically the reason why tracepoints are widely more used to attach bpf programs with respect to kprobes. So the real question is, how stable are lsm hooks ? Quite stable as I understood, but is also true that we are talking about kernel security here so total stability would probably be required in order to reliably build something trustable. Time will tell.. 

--- 

## KRSI and other fantastic beasts

Ok so in this final section I want to provide a high level view of the linux kernel and MAC solutions and help you and myself out in understanding where krsi is sitting and what it can replace/improve in this rich landscape. 

### Syscalls and Kernel resources 

In laughably simple model we have userspace applications interacting with kernel resources by means of syscalls, which is really **the stable api** seen by users and the only possible way that they have to access and claim their share of os resources. Right in front of these we have the lsm hooks enforcing protection logic. 

### Userspace vs kernelspace enforcement

There is a whole family of tools that implement security enforcement by restricting syscalls, which makes a whole lot of sense at first sight:

> If users trigger syscalls to interact with kernel state why not restricting those actions directly ?

This is exactly what tools like *seccomp* or *systrace* do in the first place. Seccomp (which stands for secure computing) is a kernel facility that enables a process to auto restrict its access to syscalls, and was extended to support bpf injection in what is currently known as **seccomp-bpf**. 
With seccomp-bpf is possible to attach bpf programs to syscalls in order to reject or pass them (quite similar to krsi right ?) which is awasome, moreover it is nicely wrapped by *libseccomp* library, the same library extesively used by **runc** in order to allow enforcement for its open-container-initiative runtime security. If you are asking yourself, yes, this is the mainmechanism behind those container *security profiles* that implement syscall access restriction both in [docker](https://docs.docker.com/engine/security/seccomp/) and [kubernetes](https://kubernetes.io/docs/tutorials/clusters/seccomp/) environments.  
So what's the problem with this approach ?  
The problem is that enforcement is performed very far from the kernel resources being protected, and relying on userspace data (e.g. paths or strings passed syscall arguments) exposes us to a whole family of subtle security exploits where this information can be manipulated after the checks have been done by exploiting race conditions (I won't enter those details here).  
So maybe you are asking yourselves:  

> Then what kind of information can I use inside my seccomp-bpf code ?

And the answer is: everything which is not passed as a pointer argument to syscalls. 
Thus formulating complex policies with seccomp-bpf is virtually impossible, as I cannot have access to very basic information such as:
* the name of the executable
* some path i am passing to my syscall

Add to that the fact that syscalls are contantly evolving, now you should have a quite clear idea on why lsm hooks were introduced. 
They offered the capabilty to implement very sophisticated security policies deep inside the linux kernel. The only problem being that every time a fix was required, a whole kernel recompilation was required. This rigidity concerning deployment is the main reason why security modules such as SELinux and AppArmor ended up being include straight in the kernel tree, event thought this wasn't likely the idea when LSM framework was conceived.  
BUT this is not the case anymore with krsi, that makes the whole developement/deployment cycle far easier to implement without even restarting the machine.

--- 

## Requirements

> Ok, but tell me what I need to play with this stuff

You need a linux kernel > 5.7 compiled with the following options:
- BPF_SYSCALL 
- DEBUG_INFO
- DEBUG_INFO_BTF  
- **BPF_LSM**

Being an extremely fresh feature, no os that I know of ships with option BPF_LSM enabled by default, yet all these will likely be enabled in the future. Ubuntu upstream kernel for example already includes in its version 5.10.0 the first three options and is likely to enable the last one [quite soon](https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1905975). 

--- 

## Wrapping the spring roll 

Writing an deployng flexible security code has never been so easy, I expect to see a number of different solutions grow building their foundation on KRSI and bpf.  
Deep lsm observability will likely become another quite crucial aspect both when deveoloping and deploying these kind of programs. That is exatcly why I wrote a simple security [**tracer**](https://github.com/lumontec/lsmtrace) to provide an high level view of what a specific process is doing at the hooks level.  
That is juice for my next post. 

